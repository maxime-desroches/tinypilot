#!/usr/bin/env python3
import time

import cereal.messaging as messaging


TEST_TIME = 90


def cputime_total(ct):
  return ct.cpuUser + ct.cpuSystem + ct.cpuChildrenUser + ct.cpuChildrenSystem


def print_cpu_usage(first_proc, last_proc):
  r = 0
  procs = [
    # (proc, max time (s))
    ("selfdrive.controls.controlsd", 59.46),
    ("selfdrive.locationd.locationd", 34.38),
    ("./loggerd", 28.49),
    ("selfdrive.controls.plannerd", 19.77),
    ("./_modeld", 12.74),
    ("selfdrive.controls.radard", 9.54),
    ("./_ui", 9.54),
    ("./camerad", 7.07),
    ("selfdrive.locationd.paramsd", 11.53),
    ("./_sensord", 6.17),
    ("selfdrive.monitoring.dmonitoringd", 5.48),
    ("./boardd", 3.63),
    ("./_dmonitoringmodeld", 2.67),
    ("selfdrive.logmessaged", 2.71),
    ("selfdrive.thermald.thermald", 2.41),
    ("selfdrive.locationd.calibrationd", 6.81),
    ("./proclogd", 1.54),
    ("./_gpsd", 0.09),
    ("./clocksd", 0.02),
    ("./ubloxd", 0.02),
    ("selfdrive.tombstoned", 0),
    ("./logcatd", 0),
  ]

  dt = (last_proc.logMonoTime - first_proc.logMonoTime) / 1e9
  print("------------------------------------------------")
  for proc_name, normal_cpu_usage in procs:
    try:
      first = [p for p in first_proc.procLog.procs if proc_name in p.cmdline][0]
      last = [p for p in last_proc.procLog.procs if proc_name in p.cmdline][0]
      cpu_time = cputime_total(last) - cputime_total(first)
      cpu_usage = cpu_time / dt * 100.
      if cpu_usage > max(normal_cpu_usage * 1.1, normal_cpu_usage + 5.0):
        print(f"Warning {proc_name} using more CPU than normal")
        r = 1

      print(f"{proc_name.ljust(35)}  {cpu_usage:.2f}%")
    except IndexError:
      print(f"{proc_name.ljust(35)}  NO METRICS FOUND")
      r = 1
  print("------------------------------------------------")

  return r

if __name__ == "__main__":

  sm = messaging.SubMaster(['procLog'])


  if os.getenv("GET_CPU_USAGE"):
    dt = time.time() - start_t

    # Get first sample
    if dt > 30 and first_proc is None:
      first_proc = messaging.recv_sock(proc_sock)

    # Get last sample and exit
    if dt > 90:
      last_proc = messaging.recv_sock(proc_sock, wait=True)

      all_running = all(running[p].is_alive() for p in car_started_processes)

      cleanup_all_processes(None, None)
      return_code = print_cpu_usage(first_proc, last_proc)

      if not all_running:
        return_code = 1
      sys.exit(return_code)


